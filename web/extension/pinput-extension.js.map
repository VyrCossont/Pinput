{"version":3,"file":"extension/pinput-extension.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./web/pinput.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./web/pinput-loader.js"],"sourcesContent":["/**\n * Pinput server for cartridges exported to web format.\n * Include this module in your exported HTML and call `Pinput.init()`,\n * and it should work the same way as the desktop versions.\n *\n * v0.1.2 by @vyr@demon.social\n */\n\nconst magic = [\n    0x02,\n    0x20,\n    0xc7,\n    0x46,\n    0x77,\n    0xab,\n    0x44,\n    0x6e,\n    0xbe,\n    0xdc,\n    0x7f,\n    0xd6,\n    0xd2,\n    0x77,\n    0x98,\n    0x4d,\n];\n\nconst maxGamepads = 8;\n\nconst gamepadStride = 16;\n\nconst connected = 1 << 0;\nconst hasGuideButton = 1 << 3;\nconst hasMiscButton = 1 << 4;\nconst hasRumble = 1 << 5;\n\n// Gamepad battery status not supported.\n\nconst buttonsLoOffset = 2;\nconst dpadUp = 1 << 0;\nconst dpadDown = 1 << 1;\nconst dpadLeft = 1 << 2;\nconst dpadRight = 1 << 3;\nconst start = 1 << 4;\nconst back = 1 << 5;\nconst leftStick = 1 << 6;\nconst rightStick = 1 << 7;\n\nconst buttonsHiOffset = 3;\nconst leftBumper = 1 << 0;\nconst rightBumper = 1 << 1;\nconst guide = 1 << 2;\nconst misc = 1 << 3;\nconst a = 1 << 4;\nconst b = 1 << 5;\nconst x = 1 << 6;\nconst y = 1 << 7;\n\nconst triggerMax = 0xff;\nconst leftTriggerOffset = 4;\nconst rightTriggerOffset = 5;\nconst triggerMappings = new Map();\ntriggerMappings.set(6, leftTriggerOffset);\ntriggerMappings.set(7, rightTriggerOffset);\n\nconst axisMax = 0x7fff;\nconst leftStickXOffset = 6;\nconst leftStickYOffset = 8;\nconst rightStickXOffset = 10;\nconst rightStickYOffset = 12;\nconst axisMappings = new Map();\naxisMappings.set(0, [leftStickXOffset, 1]);\naxisMappings.set(1, [leftStickYOffset, -1]);\naxisMappings.set(2, [rightStickXOffset, 1]);\naxisMappings.set(3, [rightStickYOffset, -1]);\n\nconst rumbleMax = 0xff;\nconst loFreqRumbleOffset = 14;\nconst hiFreqRumbleOffset = 15;\nconst rumbleDurationMs = 33; // 2 PICO-8 frames.\nconst rumbleMappings = new Map();\nrumbleMappings.set(0, [loFreqRumbleOffset, 'weakMagnitude']);\nrumbleMappings.set(1, [hiFreqRumbleOffset, 'strongMagnitude']);\n\n/** Called by `loop` to push gamepad inputs into PICO-8's GPIO area. */\nfunction sync() {\n    let gpio;\n    if (window.wrappedJSObject !== undefined) {\n        // We're in a Firefox extension content script:\n        // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Sharing_objects_with_page_scripts\n        gpio = window.wrappedJSObject.pico8_gpio;\n    } else {\n        gpio = window.pico8_gpio;\n    }\n    if (gpio === undefined) {\n        throw \"pico8_gpio is not defined yet!\";\n    }\n\n    // Check for the magic that indicates that we should initialize Pinput.\n    let shouldReinit = true;\n    for (const [i, byte] of magic.entries()) {\n        if (gpio[i] !== byte) {\n            shouldReinit = false;\n            break;\n        }\n    }\n    if (shouldReinit) {\n        // Zero the GPIO area.\n        gpio.fill(0);\n    }\n\n    // Write each supported gamepad's current state into GPIO.\n    // Note: `navigator.getGamepads()` does not return an array on Chrome.\n    for (const [gamepadIndex, gamepad] of Array.from(navigator.getGamepads()).slice(0, maxGamepads).entries()) {\n        const gamepadBase = gamepadIndex * gamepadStride;\n        if (gamepad === null || gamepad.mapping !== 'standard' || !gamepad.connected) {\n            // This is a disconnected or unsupported gamepad: zero it and go to the next one.\n            gpio.fill(0, gamepadBase, gamepadBase + gamepadStride);\n            continue;\n        }\n\n        // Detect Firefox vibration support.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/hapticActuators\n        const hasSupportedGamepadHapticActuators =\n            gamepad.hapticActuators !== undefined\n            && gamepad.hapticActuators.length >= 2\n            && gamepad.hapticActuators\n                .every(actuator => actuator.type === 'vibration');\n\n        // Detect Chrome vibration support.\n        // https://web.dev/gamepad/#making-use-of-the-vibration-actuator\n        // https://docs.google.com/document/d/1jPKzVRNzzU4dUsvLpSXm1VXPQZ8FP-0lKMT-R_p-s6g/edit\n        const hasSupportedVibrationActuator =\n            gamepad.vibrationActuator !== undefined\n            && gamepad.vibrationActuator.type === 'dual-rumble';\n\n        // Some gamepads use the standard mapping but have a `buttons` array too short to have the guide button.\n        // The Logitech F310 in DirectInput mode is an example.\n        let flags = connected;\n        if (gamepad.buttons.length > 16) {\n            flags |= hasGuideButton;\n        }\n        if (gamepad.buttons.length > 17) {\n            flags |= hasMiscButton;\n        }\n        if (hasSupportedGamepadHapticActuators || hasSupportedVibrationActuator) {\n            flags |= hasRumble;\n        }\n        gpio[gamepadBase] = flags;\n\n        // Handle low byte of buttons.\n        let buttonsLo = 0;\n        if (gamepad.buttons[12].pressed) {\n            buttonsLo |= dpadUp;\n        }\n        if (gamepad.buttons[13].pressed) {\n            buttonsLo |= dpadDown;\n        }\n        if (gamepad.buttons[14].pressed) {\n            buttonsLo |= dpadLeft;\n        }\n        if (gamepad.buttons[15].pressed) {\n            buttonsLo |= dpadRight;\n        }\n        if (gamepad.buttons[9].pressed) {\n            buttonsLo |= start;\n        }\n        if (gamepad.buttons[8].pressed) {\n            buttonsLo |= back;\n        }\n        if (gamepad.buttons[10].pressed) {\n            buttonsLo |= leftStick;\n        }\n        if (gamepad.buttons[11].pressed) {\n            buttonsLo |= rightStick;\n        }\n        gpio[gamepadBase + buttonsLoOffset] = buttonsLo;\n\n        // Handle high byte of buttons.\n        let buttonsHi = 0;\n        if (gamepad.buttons[4].pressed) {\n            buttonsHi |= leftBumper;\n        }\n        if (gamepad.buttons[5].pressed) {\n            buttonsHi |= rightBumper;\n        }\n        if (gamepad.buttons[0].pressed) {\n            buttonsHi |= a;\n        }\n        if (gamepad.buttons[1].pressed) {\n            buttonsHi |= b;\n        }\n        if (gamepad.buttons[2].pressed) {\n            buttonsHi |= x;\n        }\n        if (gamepad.buttons[3].pressed) {\n            buttonsHi |= y;\n        }\n        if (gamepad.buttons.length > 16 && gamepad.buttons[16].pressed) {\n            buttonsHi |= guide;\n        }\n        if (gamepad.buttons.length > 17 && gamepad.buttons[17].pressed) {\n            buttonsHi |= misc;\n        }\n        gpio[gamepadBase + buttonsHiOffset] = buttonsHi;\n\n        // Map triggers.\n        // Triggers are considered analog buttons, not axes.\n        for (const [buttonIndex, triggerOffset] of triggerMappings) {\n            const triggerValue = gamepad.buttons[buttonIndex].value * triggerMax;\n            gpio[gamepadBase + triggerOffset] = triggerValue;\n        }\n\n        // Map axes. Y axes have to be flipped to match XInput/Apple Game Controller conventions for up.\n        for (const [axisIndex, [axisOffset, axisMultiplier]] of axisMappings) {\n            const axisValue = gamepad.axes[axisIndex] * axisMultiplier * axisMax;\n            const axisLo = (axisValue >>> 0) & 0xff;\n            gpio[gamepadBase + axisOffset] = axisLo;\n            const axisHi = (axisValue >>> 8) & 0xff;\n            gpio[gamepadBase + axisOffset + 1] = axisHi;\n        }\n\n        // Rumble, if this browser and gamepad support it.\n        if (hasSupportedGamepadHapticActuators) {\n            for (const [rumbleIndex, [rumbleOffset, _]] of rumbleMappings) {\n                const rumble = gpio[gamepadBase + rumbleOffset] / rumbleMax;\n                const _ = gamepad.hapticActuators[rumbleIndex].pulse(rumble, rumbleDurationMs);\n            }\n        } else if (hasSupportedVibrationActuator) {\n            const effect = {\n                startDelay: 0,\n                duration: rumbleDurationMs,\n            }\n            for (const [_, [rumbleOffset, rumbleKey]] of rumbleMappings) {\n                effect[rumbleKey] = gpio[gamepadBase + rumbleOffset] / rumbleMax;\n            }\n            gamepad.vibrationActuator.playEffect('dual-rumble', effect);\n        }\n    }\n}\n\n/** Runs `sync` in a try-catch block and then schedules itself again. */\nfunction loop() {\n    try {\n        sync();\n    } catch (error) {\n        console.error(`Pinput: ${error}`);\n    }\n    window.requestAnimationFrame(loop);\n}\n\n/** Call this to start running the update loop. */\nexport function init() {\n    console.log('Pinput: initialized');\n    window.requestAnimationFrame(loop);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// JS module that imports and starts Pinput.\nimport * as Pinput from './pinput.js';\nif (typeof chrome !== 'undefined'\n    && typeof chrome.runtime !== 'undefined'\n    && typeof chrome.runtime.getURL !== 'undefined') {\n    /*\n     * We're in a Chrome content script, and we have to inject\n     * a script tag with the entire content script into the document,\n     * so that it has access to the same DOM as the PICO-8 player.\n     * See <https://stackoverflow.com/a/57318604>.\n     */\n    console.log('Pinput loader: injecting script');\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('pinput-extension.js');\n    document.documentElement.appendChild(script);\n} else {\n    Pinput.init();\n}\n"],"names":[],"sourceRoot":""}